"""Ошибки"""
"""Ошибки, с которыми программа заканчивает свое выполнение - это исключения"""
try:
    #здесь мы ловим исключения
    a = "no string"
    i = int(a)
    print(b)    #до сюда программа не дойдет, т.к. ошибка будет раньше
except ValueError as e:    #создаем "объект" как правило е - error
    print("Отловили и обработали ValueError")
    print(e)
except:
    #без рагументов - обрабатывает любые ошибки
    print("любая ошибка!")
#такая схема  - это дорого. например, мы сделали запрос в базу данных, а ответа нет. тут исключение - бросать не очень, т.к. ситуация не исключительная


try:
    #Выбрасываем ошибку
    raise RuntimeError("это тренировочный выброс об ошибки")

except RuntimeError as e:
    print(e)


#зачем выбрасывать исключения? - это мощнейший инструмент обработки ошибок. можно выбрасывать ошибку, а другие будут ее обрабатывать
#пока что можно использовать стандартные ошибки


class MyCustomError(BaseException): # в случае с классом возможна верблюжбя нотация
    pass


#try:
 #   raise MyCustomError("что-то пошло не так!")
#except MyCustomError as e:
 #   print(e)

try:
    f = open("main.py")
    s = f.readd()
except AttributeError as e:
    print(e, a)    
finally:
    print("Закрыть файл!!!")
    print(f, a)
    f.close()
    
# контекстный менеджер - дает конструкцию try - finally - закрывает файл (если было ошибка) и выбрасывает ошибку
# В ежедневнике обыгратсья с ошибками

# модуль логинг
# декораторы
